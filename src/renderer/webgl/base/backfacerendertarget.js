/**
 * @param context
 * @param opt
 * @constructor
 * @implements IRenderTarget
 * is used in backface pass for volume rendering
 */
var GLBackfaceRenderTarget = function (context, opt) {
    this.context = context;
    this.width = context.gl.drawingBufferWidth;
    this.height = context.gl.drawingBufferHeight;
    this.opt = this.fillOptions(opt);
    this.scale = this.opt.scale || 1;

    this.frameBuffer = null;
    this.renderBuffer = null;
    this.backfaceSamplerTexture = null;

    this.valid = false;
};

XML3D.extend(GLBackfaceRenderTarget.prototype, {
    getWidth: function () {
        return this.width;
    }, getHeight: function () {
        return this.height;
    }, getScale: function () {
        return this.scale;
    }, bind: function () {
        var created = false;
        if (!this.frameBuffer) {
            this.allocateBackfaceBuffer();
            created = true;
        }
        if (this.valid) {
            var gl = this.context.gl;

            gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
            gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.bindTexture(gl.TEXTURE_2D, this.backfaceSamplerTexture.handle);

            if (this.checkDrawingBufferSize(gl)) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.FLOAT, null);
            }

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);

            // Set default viewport
            created && gl.viewport(0, 0, this.width, this.height);
        }
    }, unbind: function () {
        var gl = this.context.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }, resize: function (width, height) {
        this.dispose();
        this.width = width;
        this.height = height;
        this.bind();
    }, allocateBackfaceBuffer: function () {
        var gl = this.context.gl;

        this.frameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

        this.backfaceSamplerTexture = this.context.createTexture();
        this.backfaceSamplerTexture.createTex2DFromData(gl.RGBA, this.width, this.height, gl.RGBA, gl.FLOAT, this.opt);
        this.backfaceSamplerTexture.autoGenerated = true;

        this.renderBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.backfaceSamplerTexture.handle, 0);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        this.allocatedDrawingBufferSize = new Float32Array([gl.drawingBufferWidth, gl.drawingBufferHeight]);

        this.checkStatus();
    }, checkDrawingBufferSize: function (gl) {
        if ((this.allocatedDrawingBufferSize[0] != gl.drawingBufferWidth) || (this.allocatedDrawingBufferSize[1] != gl.drawingBufferHeight)) {

            this.allocatedDrawingBufferSize[0] = this.width = gl.drawingBufferWidth;
            this.allocatedDrawingBufferSize[1] = this.height = gl.drawingBufferHeight;
            return true;
        }
        return false;
    }, checkStatus: function () {
        var gl = this.context.gl;

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        //Finalize framebuffer creation
        var fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

        switch (fbStatus) {
            case gl.FRAMEBUFFER_COMPLETE:
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                break;
            case gl.FRAMEBUFFER_UNSUPPORTED:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                break;
            default:
                XML3D.debug.logError("Incomplete framebuffer: " + fbStatus);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        this.valid = (fbStatus == gl.FRAMEBUFFER_COMPLETE);

        return this.valid;
    }, fillOptions: function (options) {
        var gl = this.context.gl;
        var opt = {
            wrapS: gl.CLAMP_TO_EDGE, wrapT: gl.CLAMP_TO_EDGE, minFilter: gl.NEAREST, magFilter: gl.NEAREST
        };

        for (var item in options) {
            opt[item] = options[item];
        }
        return opt;
    }, dispose: function () {
        if (!this.frameBuffer)
            return;

        var gl = this.context.gl;
        gl.deleteFramebuffer(this.frameBuffer);
        this.backfaceSamplerTexture.handle.dispose();
        gl.deleteRenderBuffer(this.renderBuffer);

    }
});

module.exports = GLBackfaceRenderTarget;

